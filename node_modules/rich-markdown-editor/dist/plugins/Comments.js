"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const prosemirror_state_1 = require("prosemirror-state");
const uuid_1 = __importDefault(require("uuid"));
const prosemirror_view_1 = require("prosemirror-view");
const Extension_1 = __importDefault(require("../lib/Extension"));
exports.plugin = new prosemirror_state_1.PluginKey("comments");
function createCommentDecoration(from, to, id, selected) {
    return prosemirror_view_1.Decoration.inline(from, to, { class: selected ? "comment selected" : "comment", id }, { id });
}
class CommentState {
    constructor(decos, selectedId) {
        this.decos = decos;
        this.selectedId = selectedId;
    }
    findComment(id) {
        const current = this.decos.find();
        for (let i = 0; i < current.length; i++) {
            if (current[i].spec.id === id) {
                return current[i];
            }
        }
    }
    commentsAt(pos) {
        return this.decos.find(pos, pos);
    }
    apply(tr) {
        const action = tr.getMeta(exports.plugin);
        const actionType = action && action.type;
        if (!action && !tr.docChanged) {
            return this;
        }
        if (actionType === "receive") {
            const decos = action.comments.map(comment => createCommentDecoration(comment.from, comment.to, comment.id, comment.id === this.selectedId));
            return new CommentState(prosemirror_view_1.DecorationSet.create(tr.doc, decos), this.selectedId);
        }
        let decos = this.decos;
        let selectedId = this.selectedId;
        decos = decos.map(tr.mapping, tr.doc);
        if (actionType === "select") {
            const previous = this.findComment(this.selectedId);
            decos = decos.remove([previous]);
            const comment = this.findComment(action.id);
            selectedId = action.id;
            if (comment) {
                decos = decos.add(tr.doc, [
                    createCommentDecoration(comment.from, comment.to, comment.id, true),
                ]);
            }
        }
        else if (actionType === "newComment") {
            decos = decos.add(tr.doc, [
                createCommentDecoration(action.from, action.to, action.id, true),
            ]);
            selectedId = action.id;
        }
        else if (actionType === "deleteComment") {
            decos = decos.remove([this.findComment(action.id)]);
        }
        return new CommentState(decos, selectedId);
    }
    static init(state, comments = []) {
        const decos = comments.map(comment => createCommentDecoration(comment.from, comment.to, comment.id, false));
        return new CommentState(prosemirror_view_1.DecorationSet.create(state.doc, decos), null);
    }
}
function isCommentActive(state) {
    return !!exports.plugin.getState(state).commentsAt(state.selection.from).length;
}
exports.isCommentActive = isCommentActive;
class Comments extends Extension_1.default {
    get name() {
        return "comments";
    }
    keys() {
        return {
            "Alt-Mod-m": (state, dispatch) => {
                const sel = state.selection;
                if (sel.empty)
                    return false;
                if (!this.options.onSelectComment)
                    return;
                const decos = exports.plugin.getState(state).commentsAt(sel.from);
                if (decos.length) {
                    return true;
                }
                const id = uuid_1.default.v4();
                const comment = {
                    type: "newComment",
                    from: sel.from,
                    to: sel.to,
                    id,
                };
                dispatch(state.tr.setMeta(exports.plugin, comment));
                this.options.onSelectComment({
                    from: sel.from,
                    to: sel.to,
                    id,
                });
                return true;
            },
        };
    }
    commands() {
        return () => (state, dispatch) => {
            const id = uuid_1.default.v4();
            const sel = state.selection;
            dispatch(state.tr.setMeta(exports.plugin, {
                type: "newComment",
                from: sel.from,
                to: sel.to,
                id,
            }));
            this.options.onSelectComment({
                from: sel.from,
                to: sel.to,
                id,
            });
            return true;
        };
    }
    get plugins() {
        const handleSelectComment = view => {
            if (this.options.onSelectComment) {
                const { state, dispatch } = view;
                const sel = state.selection;
                if (!sel.empty)
                    return false;
                const decos = exports.plugin.getState(state).commentsAt(sel.from);
                const selectedId = exports.plugin.getState(state).selectedId;
                if (!decos.length) {
                    if (selectedId) {
                        dispatch(state.tr.setMeta(exports.plugin, {
                            type: "select",
                            id: null,
                        }));
                        this.options.onSelectComment(null);
                    }
                    return false;
                }
                const { id } = decos[0].spec;
                if (selectedId === id)
                    return false;
                dispatch(state.tr.setMeta(exports.plugin, {
                    type: "select",
                    id,
                }));
                this.options.onSelectComment({
                    from: decos[0].from,
                    to: decos[0].to,
                    id,
                });
            }
            return false;
        };
        return [
            new prosemirror_state_1.Plugin({
                key: exports.plugin,
                state: {
                    init: state => CommentState.init(state, this.options.comments),
                    apply: (tr, prev) => prev.apply(tr),
                },
                props: {
                    decorations(state) {
                        return this.getState(state).decos;
                    },
                    handleDOMEvents: {
                        mouseup: handleSelectComment,
                        keyup: handleSelectComment,
                    },
                },
            }),
        ];
    }
}
exports.default = Comments;
//# sourceMappingURL=Comments.js.map